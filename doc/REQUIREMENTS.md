# MessageToolkit 需求规格说明书

## 1. 概述

### 1.1 项目背景

在工业自动化和设备通信领域，经常需要与 PLC、传感器、执行器等设备进行数据交互。这些设备通常使用 Modbus 协议（基于寄存器的字节通信）或 IO 点位协议（基于位的布尔通信）。开发人员需要手动处理：

- 数据类型与字节数组之间的转换
- 字节序（大端/小端）处理
- 地址计算和偏移管理
- 多字段的批量读写优化

这些重复性工作容易出错，且代码难以维护。

### 1.2 项目目标

MessageToolkit 是一个 .NET 类库，旨在提供：

1. **类型安全的协议定义** - 使用 C# 结构体定义通信协议，通过特性标记地址
2. **自动编解码** - 自动处理数据类型与字节/位数组之间的转换
3. **帧构建器** - 简化读写帧的构建过程
4. **批量优化** - 自动合并连续地址的写入操作，减少通信次数
5. **双协议支持** - 同时支持 Modbus 字节帧和 IO 位帧

### 1.3 适用范围

- .NET 8.0 及以上版本
- 工业自动化设备通信
- Modbus RTU/TCP 协议
- 数字 IO 点位读写

---

## 2. 功能需求

### 2.1 协议定义 (Protocol Definition)

#### 2.1.1 地址特性标记

**需求描述**：用户可以使用 `[Address]` 特性标记结构体的属性，指定该字段在通信协议中的地址。

**功能要求**：
- 支持 `ushort` 类型的地址值
- 可应用于属性和字段
- 地址值代表字节偏移量

**使用示例**：
```csharp
public struct DeviceProtocol
{
    [Address(100)] public int Speed { get; set; }        // 地址 100，占 4 字节
    [Address(104)] public float Temperature { get; set; } // 地址 104，占 4 字节
    [Address(108)] public bool IsRunning { get; set; }    // 地址 108，占 2/4 字节
    [Address(110)] public short Status { get; set; }      // 地址 110，占 2 字节
}
```

#### 2.1.2 支持的数据类型

**需求描述**：协议字段应支持常见的 unmanaged 值类型。

**支持的类型**：
| 类型 | 大小 | 说明 |
|------|------|------|
| `byte` | 1 字节 | 无符号 8 位整数 |
| `sbyte` | 1 字节 | 有符号 8 位整数 |
| `short` | 2 字节 | 有符号 16 位整数 |
| `ushort` | 2 字节 | 无符号 16 位整数 |
| `int` | 4 字节 | 有符号 32 位整数 |
| `uint` | 4 字节 | 无符号 32 位整数 |
| `long` | 8 字节 | 有符号 64 位整数 |
| `ulong` | 8 字节 | 无符号 64 位整数 |
| `float` | 4 字节 | 单精度浮点数 |
| `double` | 8 字节 | 双精度浮点数 |
| `bool` | 2/4 字节 | 布尔值（可配置表示方式） |

#### 2.1.3 布尔类型表示

**需求描述**：布尔类型在 Modbus 协议中通常占用 2 或 4 字节。

**配置选项**：
- `Int16` - 使用 2 字节表示布尔值（0x0000 = false, 0x0001 = true）
- `Int32` - 使用 4 字节表示布尔值

#### 2.1.4 字节序配置

**需求描述**：支持大端序和小端序的数据编码。

**配置选项**：
- `BigEndian` - 大端序（Modbus 标准）
- `LittleEndian` - 小端序

---

### 2.2 协议模式 (Protocol Schema)

#### 2.2.1 自动解析

**需求描述**：系统应自动解析协议结构体，提取地址和类型信息。

**功能要求**：
- 自动计算协议起始地址（所有字段中的最小地址）
- 自动计算协议总大小（覆盖所有字段的字节范围）
- 提取所有字段的地址、类型、大小信息
- 识别布尔类型字段

#### 2.2.2 字段信息查询

**需求描述**：提供 API 查询协议字段信息。

**功能要求**：
- 根据字段名获取地址
- 根据 Lambda 表达式获取地址
- 获取字段的完整信息（名称、地址、类型、大小）

---

### 2.3 编解码器 (Protocol Codec)

#### 2.3.1 协议编码

**需求描述**：将协议结构体序列化为数据数组。

**功能要求**：
- 支持整个协议的编码
- 支持单个字段值的编码
- 处理字节序转换
- 处理布尔类型表示转换

#### 2.3.2 协议解码

**需求描述**：从数据数组反序列化为协议结构体。

**功能要求**：
- 支持整个协议的解码
- 支持单个字段值的解码
- 数据长度校验
- 字节序转换

#### 2.3.3 双协议支持

**需求描述**：支持两种数据载荷类型。

| 协议类型 | 数据类型 | 适用场景 |
|----------|----------|----------|
| Modbus 字节帧 | `byte[]` | 寄存器读写 |
| IO 位帧 | `bool[]` | 数字 IO 点位读写 |

---

### 2.4 帧构建器 (Frame Builder)

#### 2.4.1 写入帧构建

**需求描述**：构建用于写入数据的帧。

**功能要求**：
- 构建整个协议的写入帧
- 构建单个字段的写入帧（通过 Lambda 表达式选择字段）
- 构建指定地址的写入帧

**输出信息**：
- 起始地址
- 数据载荷
- 数据长度
- 寄存器数量（Modbus）/ 点位数量（IO）

#### 2.4.2 读取请求构建

**需求描述**：构建用于读取数据的请求。

**功能要求**：
- 构建整个协议的读取请求
- 构建单个字段的读取请求
- 构建指定地址和数量的读取请求

**输出信息**：
- 起始地址
- 读取数量
- 字节数（Modbus）

---

### 2.5 数据映射 (Data Mapping)

#### 2.5.1 批量写入

**需求描述**：支持批量添加多个字段的写入操作。

**功能要求**：
- 链式 API 添加写入操作
- 支持通过 Lambda 表达式指定字段
- 支持直接指定地址
- 支持 Fluent API 风格（Property + Value）

**使用示例**：
```csharp
// 链式写入
builder.CreateDataMapping()
    .Property(p => p.Speed, 1500)
    .Property(p => p.Temperature, 25.5f)
    .Property(p => p.IsRunning, true)
    .Build();

// Fluent API 风格
builder.CreateDataMapping()
    .Property(p => p.Speed).Value(1500)
    .Property(p => p.Temperature).Value(25.5f)
    .Build();
```

#### 2.5.2 帧优化

**需求描述**：自动合并连续地址的写入操作，生成最少的帧。

**优化规则**：
- 按地址排序所有写入操作
- 合并地址连续的写入为单个帧
- 地址不连续的写入生成独立的帧

**示例**：
```
输入：
  - 写入地址 100, 数据 4 字节
  - 写入地址 104, 数据 4 字节
  - 写入地址 200, 数据 2 字节

输出（优化后）：
  - 帧1: 起始地址 100, 数据 8 字节（合并了 100 和 104）
  - 帧2: 起始地址 200, 数据 2 字节
```

#### 2.5.3 清空与重置

**需求描述**：支持清空已添加的写入操作。

**功能要求**：
- `Clear()` 方法清空所有待写入数据
- `Count` 属性查询当前待写入操作数量

---

### 2.6 依赖注入支持

#### 2.6.1 服务注册

**需求描述**：提供 Microsoft.Extensions.DependencyInjection 集成。

**功能要求**：
- `AddMessageToolkit()` - 添加基础服务
- `AddModbusProtocol<TProtocol>()` - 注册 Modbus 字节帧协议
- `AddBitProtocol<TProtocol>()` - 注册 IO 位帧协议

**配置选项**：
- 布尔类型表示方式
- 字节序

---

## 3. 非功能需求

### 3.1 性能要求

- 编解码操作应高效，避免不必要的内存分配
- 使用 `ReadOnlySpan<T>` 和 `ReadOnlyMemory<T>` 减少复制
- 支持结构体以避免堆分配

### 3.2 可扩展性

- 接口抽象设计，支持自定义实现
- 泛型设计，支持任意协议结构体
- 支持扩展新的数据载荷类型

### 3.3 可维护性

- 清晰的代码结构和命名
- 完整的 XML 文档注释
- 单元测试覆盖核心功能

### 3.4 兼容性

- 目标框架：.NET 8.0
- 无外部依赖（除 Microsoft.Extensions.DependencyInjection.Abstractions）

---

## 4. 接口规范

### 4.1 核心接口

```
IProtocolSchema<TProtocol>     - 协议模式接口
IProtocolCodec<TProtocol, TData> - 编解码器接口
IFrameBuilder<TProtocol, TData>  - 帧构建器接口
IDataMapping<TProtocol, TData>   - 数据映射接口
IFrame<TData>                    - 帧接口
IWriteFrame<TData>               - 写入帧接口
IReadRequest                     - 读取请求接口
IValueSetter<TProtocol, TData>   - 值设置器接口（Fluent API）
```

### 4.2 实现类

```
ProtocolSchema<TProtocol>        - 协议模式实现
ProtocolCodec<TProtocol>         - Modbus 编解码器
BitProtocolCodec<TProtocol>      - IO 位编解码器
ModbusFrameBuilder<TProtocol>    - Modbus 帧构建器
BitFrameBuilder<TProtocol>       - IO 位帧构建器
ModbusWriteFrame                 - Modbus 写入帧
ModbusReadRequest                - Modbus 读取请求
BitWriteFrame                    - IO 位写入帧
BitReadRequest                   - IO 位读取请求
```

---

## 5. 使用场景

### 5.1 场景一：Modbus 设备通信

**描述**：与 Modbus TCP/RTU 设备进行寄存器读写。

**流程**：
1. 定义协议结构体，标记地址
2. 注册服务或直接实例化构建器
3. 构建写入帧，发送到设备
4. 构建读取请求，读取设备数据
5. 解码响应数据为协议结构体

### 5.2 场景二：IO 点位控制

**描述**：控制数字 IO 模块的输入/输出点位。

**流程**：
1. 定义 DI/DO 协议结构体（仅包含 bool 字段）
2. 使用位帧构建器
3. 批量设置多个 DO 点位
4. 读取 DI 点位状态

### 5.3 场景三：批量参数下发

**描述**：一次性下发多个参数到设备。

**流程**：
1. 使用数据映射批量添加参数
2. 调用 `BuildOptimized()` 生成优化后的帧
3. 依次发送各帧到设备

---

## 6. 约束与限制

1. 协议结构体必须是值类型（`struct`）
2. 协议字段必须是 `unmanaged` 类型
3. 地址必须显式标记，不支持自动推断
4. 不包含通信层实现，仅负责帧的构建和数据编解码

---

## 7. 术语表

| 术语 | 定义 |
|------|------|
| 帧 (Frame) | 一个完整的通信数据单元 |
| 协议 (Protocol) | 定义数据结构和地址映射的结构体 |
| 编码 (Encode) | 将结构体转换为字节/位数组 |
| 解码 (Decode) | 将字节/位数组转换为结构体 |
| 寄存器 (Register) | Modbus 中的 16 位数据单元 |
| 字节序 (Endianness) | 多字节数据的存储顺序 |

---

## 版本历史

| 版本 | 日期 | 说明 |
|------|------|------|
| 1.0 | 2025-12 | 初始版本，支持 Modbus 字节帧和 IO 位帧 |
